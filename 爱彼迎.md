# 爱彼迎Demo笔记
## 项目准备(*)
### 项目规范
- 项目规范: 
  - 命名规范:
    - 文件夹,文件名统一小写,多个单词由`-`连接
    - js变量小驼峰,常量全大写,组件大驼峰
  - css方面: 全局采用普通css,局部采用style-component
  - 整个项目全面使用Hooks
  - 全部函数式组件为了避免不必要渲染,统一用memo包裹
  - 组件之间的数据管理: useState,useReducer + redux管理
  - 组件内部代码编写顺序
    - state管理 (props/useState)
    - redux的hooks代码 (useSelector/useDispatch)
    - 其他hooks代码(自定义hooks)
    - 其他逻辑代码 (网络请求/事件监听/副作用)
    - 返回JSX代码
  - redux两种模式: 普通模式 / RTK模式都会使用
  - 网络请求axios的二次封装,所有模块请求统一放到一个文件中单独管理
  - 项目使用AntDesign(国内) Material UI(国外)
    - 爱彼迎设计风格偏向于Material UI
    - 大部分组件还需要自己编写,封装,实现

### 项目构建
- ==**很多东西可以照着Vue宏源旅途的笔记配置**==
- 1.vite创建react项目(仅js) --- airbnb
  > ==**由于react官方已经弃用了create-react-app,推荐vite等脚手架构建react项目,所以项目转向vite构建**==
- 2.项目标题和图标(/public),在index.html配置
- 3.引入jsconfig.json文件,更好地提示
- 4.创建的目录结构如下: 
  - pubilc: 动态可修改图片 (仅能简单理解)
  - src
    - assets: 静态不可修改图片
    - base-ui: 基础ui,在多个项目中使用
    - components: 公共多复用的组件
    - hooks
    - router
    - service: 网络请求相关
    - store
    - utils: 工具函数
    - views: 页面视图
- 5.配置别名: 
  - 下载`npm i @vitejs/plugin-vue`, 然后引入 path 并配置
  ```js
    // 引入path
    import path from 'path'

    // vite.config.js内部分代码
    resolve: {
      alias: {
        '@': path.resolve(__dirname, 'src')
      }
    }
  ```
  > @: 代表绝对路径下的 src 路径,以后配置 src 下的文件可以直接@代替,例如`@/componets/tabbae/tabbar.vue`
- 进一步配置更多的别名,比如
  ```js
    // alias原理: 别名 + 绝对路径
    // 绝对路径由path负责,__dirname会获取当前文件夹下的绝对路径,即/airbnb,再使用resolve进行路径拼接
    const resolve = pathName => path.resolve(__dirname, pathName)

    export default defineConfig({
      plugins: [react()],
      resolve: {
        alias: {
          '@': resolve('src'),
          'components': resolve('src/components'),
          'utils': resolve('src/utils')
        }
      }
    })
  ```
- 6.使用less和全局重置css样式 (==css代码复制宏远旅途==)
  - 直接下载 `npm i less`,然后可以直接使用,在文件引入css/less文件即可
  - 通用的重置css库: `npm i normalize.css` 
  - 自己写的重置样式: `/assets/css/reset.less` 
    > 为了方便,所有css样式统一引入index.css,然后由main.jsx引入index.css实现样式转变
  - ==main.jsx中不可以省略index.css,写完整==
    ```js
      import { StrictMode } from 'react'
      import { createRoot } from 'react-dom/client'
      import App from '@/App'
      import '@/assets/css/index.css'

      createRoot(document.getElementById('root')).render(
        <StrictMode>
          <App />
        </StrictMode>,
      )
    ```
  - 额外的,配置less主题颜色 `/assets/variable.less`
    ```css
      @textColor: #484848;
      @textColorSecondary: #222;
    ```
  - ==vite默认支持CSS Modules==, 任何以 .module.css 为后缀名的 CSS 文件都被认为是一个 CSS modules 文件。导入这样的文件会返回一个相应的模块对象, **但是项目中以'css in js'方案,也就是styled-components为主,所以需要下载`npm i styled-components`**

### 路由配置
- vite中配置react路由和原本没有啥区别
- react-router现在已经推出v7版本,为最新版,优化比较多,对应的更新日志说明(从v6更新)和掘金上react-router v7使用说明 两篇文章均已收藏
- ==本质上v6->v7的变化不大,所以本项目使用v6版本==
- 下载: `npm i react-router-dom@6`,
- 1.创建三个页面 home/detail/entire
- 2.配置router/index 配置各种路由(懒加载+重定向+NotFound)
  ```js
    import React from "react";
    // 重定向
    import { Navigate } from "react-router-dom";

    // 懒加载,异步加载,需要在main.jsx中额外配置Suspense
    const Home = React.lazy(() => import('@/views/home'))
    const Detail = React.lazy(() => import('@/views/detail'))
    const Entire = React.lazy(() => import('@/views/entire'))
    const NotFound = React.lazy(() => import('@/views/notfound'))

    const routes = [
      {
        path: '/',
        element: <Navigate to='/home' />
      },
      {
        path: '/home',
        element: <Home />
      },
      {
        path: '/detail',
        element: <Detail />
      },
      {
        path: '/entire',
        element: <Entire />
      },
      {
        path: '*',
        element: <NotFound />
      }
    ]

    export default routes
  ```
- 3.在main.jsx配置Hash路由,另外路由懒加载需要在main.jsx配置Suspense处理异步的加载问题
  ```js
    // 路由模式 Hash
    import { HashRouter } from 'react-router-dom'
    // 组件的异步加载方案
    import { Suspense } from 'react'

    <StrictMode>
      {/* 可以选择字符串或组件,在加载过程中显示 */}
      <Suspense fallback='loading' >  
        {/* hash模式路由 */}
        <HashRouter>
          <App />
        </HashRouter>
      </Suspense>
    </StrictMode>
  ```
- 4.App.jsx使用路由
  ```js
    import React, { memo } from 'react'
    import routes from '@/router'
    import { useRoutes } from 'react-router-dom'

    const App = memo(() => {
      return (
        <div className='app'>
          <div className='header'>header</div>
          <div className='page'>
            {useRoutes(routes)}
          </div>
          <div className='footer'>footer</div>
        </div>
      )
    })

    export default App
  ```
  > ==useRoutes约等于vue的router-view==

### redux状态管理
- vite中配置redux和原本没有啥区别
- ==优先使用redux/toolkit,可以穿插使用redux原生写法,不过toolkit未来是主流,它是语法糖,极大简化了redux的代码书写,为了练习两种写法都会用到==
- 下载: `npm i @reduxjs/toolkit react-redux redux`, react-redux负责连接redux和react
- 1.==配置reducer, 在/modules内,使用RTK和原版两种方式配置==
  - 1.1 首页home因为数据过多,所以使用RTK写法
    ```js
      // /modules/home.js
      import { createSlice } from "@reduxjs/toolkit";

      const homeSlice = createSlice({
        name: 'home',
        initialState: {
          product: []
        },
        reducers: {

        }
      })

      export default homeSlice.reducer
    ```
  - 1.2 entire页面使用原生配置,创建文件夹 + 4个文件 (==出于练习目的,以后推荐统一RTK==)
    ```js
    // reducer.js
    const initialState = {
      currentNumber: 0
    }

    function reducer(state = initialState, action) {
      switch (action.type) {
        // case ...
        default:
          return state
      }
    }

    export default reducer
    ```
    ```js
      // index.js
      import reducer from './reducer'
      export default reducer
    ```
- ==2.store/index配置(RTK)==
  ```js
    import { configureStore } from '@reduxjs/toolkit'
    import homeReducer from './modules/home' // RTK(redux/toolkit)
    import entireReducer from './modules/entire' // 普通redux

    // 支持所有的reducer函数引入(RTK/普通模式)
    const store = configureStore({
      reducer: {
        home: homeReducer,
        entire: entireReducer
      }
    })

    export default store
  ```
  > ==// 支持所有的reducer函数引入(RTK/普通模式)==
- 3.main.jsx引入store
  ```js
    // store共享
    import { Provider } from 'react-redux'
    import store from "@/store" // 引入store
    
    createRoot(document.getElementById('root')).render(
      <Suspense fallback='loading' >
        {/* 公开引入的store */}
        <Provider store={store}>
          <HashRouter>
            <App />
          </HashRouter>
        </Provider>
      </Suspense>
    )
  ```

### axios封装
- 之前封装过,在网络请求相关的笔记中,下载: `npm i axios`
- service文件夹结构略,axios封装代码(==简易版,和网络请求笔记中一样,略==)
- 配置的基础测试路径为: `http://codercba.com:1888/airbnb/api` (==接口文档已配置==)
- 测试网络请求时可以关闭严格模式,这样就不会连续请求2次了
- home页面的测试
  ```js
    const home = memo(() => {
      // 简单使用,后面的网络请求会融入到redux中
      // 定义状态 
      const [highscore, setHightScore] = useState({})

      // 网络请求代码,类似Mount
      useEffect(() => {
        hyRequest.get({ url: '/home/highscore' }).then(res => {
          // console.log(res)
          setHightScore(res)
        })
      }, [])

      return (
        <div>home
          {/* 简单测试 */}
          <h2>{highscore.title}</h2>
          <h4>{highscore.subtitle}</h4>
          <ul>
            {/* 异步初始没有数据,使用可选链 */}
            {
              highscore?.list?.map(item => {
                return <li key={item.id}>{item.name}</li>
              })
            }
          </ul>
        </div>
      )
    })
  ```
## Header搭建
- ==针对Header的搭建==,爱彼迎网站的header有3种样式,并且在下滑时,有的顶部栏样式会变化,有的会fixed,有的不会fixed,区别比较大,不好做;
- ==方案一: 写一个组件,对应改变状态 方案二: 搞3个实例header,一个页面一个header,更简单==
- ==选择方案一==: App.jsx中的header部分封装为组件 -> components (同理footer也顺带封装)
  - ==header分为左中右三个部分,布局居中的思路==,左右两侧宽度不同,如果左右设定好宽度,中间flex: 1,在最后中间部分align-center肯定是不居中的; 所以应当左右两侧flex: 1(平分center剩余的宽度),中间设定宽度,这样一定居中,在对应的文件style.js配置样式
### logo与主题(*)
- ==**针对左侧LeftHeader**==
- ==左侧部分的logo部分: svg的深入学习后面学习图形处理再学习(大屏可视化Canvans等)==
  - svg不同于png jpg等图片可以直接下载,它是形如`<svg><path></path></svg>`格式的元素,是js渲染出的图案,我们复制网站的svg元素,存入`assets/svg`中,以reactElement的格式导出(.jsx),然后在对应的文件引入即可,其中svg中的style属性不支持字符串(这是jsx),需要`style={{css属性书写}}`,内置对象,需要额外的转化函数,coderwhy老师对于这种转化麻烦的函数可以直接从standoverflow上面找,style转obj的函数(都是正则表达式),已存入svg/utils文件中,在对应svg文件中直接引入使用,对应的字符串css样式传入函数即可
- ==定制主题theme,另外Ant Design上面也有一些预制主题==
  - styled-components有一个ThemeProvider方法,和共享store一样,可以共享主题
    ```js
      // 最外层index.js
      // styled-components 主题共享
      import { ThemeProvider } from 'styled-components'
      // 引入css主题
      import theme from '@/assets/theme' 

      {/* 公开store */}
      <Provider store={store}>
        {/* 公开css主题 theme */}
        <ThemeProvider theme={theme}>
          <HashRouter>
            <App />
          </HashRouter>
        </ThemeProvider>
      </Provider>
    ```
  - 配置主题theme `assets/theme/index.js`
    ```js
      const theme = {
        color: {
          primaryColor: "#ff385c",
          secondaryColor: "#00848A"
        }
      }

      export default theme
    ```
    > 可以写多个,比如有的网站有白天和黑夜2个模式,这里也可以设置多个不同的主题
  - ==使用主题,给Airbnb的logo和字体添加主题颜色==
  - 同时给logo优化: 加点击cursor: pointer属性和间距等css样式
    ```js
      import styled from 'styled-components'

      export const LeftWrapper = styled.div`
          flex: 1;
          color: ${props => props.theme.color.primaryColor};
          .left{
            display: flex;
            align-items: center;
            .logo{
              padding-left: 15px;
              cursor: pointer;
            }
          .text{
            cursor: pointer;
            padding-left: 8px;
            color: ${props => props.theme.color.primaryColor};
          }
        } 
    ```
    > ==模板字符串中使用变量`${}`,传入的theme在props参数内,这是函数调用的一种特殊方式,所以可以直接在`${}`内直接获取到props,进而找到公开的主题==
### RightHeader
- 主要学习css的样式
- 简单的2个svg图片和按钮样式(由div模仿),补充了一些主题色,配置了一些css样式,代码略,详见对应header-right/style.js
- ==less样式混入,把css样式当作字符串抽取==
  ```js
    // 主题 /assets/theme/index.js
    const theme = {
      // ...
      mixin:{
        /* 阴影+动画过渡 */
        boxShadow: ` 
          transition: box-shadow 200ms ease;
          &:hover{
            box-shadow: 0 2px 4px rgba(0,0,0,.18); 
          }
        `
      }
    }
    export default theme
  ```
- 在使用时直接引入即可
  ```js
    .profile{
      // ....
      // 引入阴影部分的css代码
      ${props => props.theme.mixin.boxShadow}
    }
  ```
### CenterHeader(略)
- 简单配置了样式和页面结构,简单看下代码即可,搜索框+svg(搜索图标),略
### Profile动态面板(*)
- 点击RightHeader的Menu图标,也是个人中心区域(Profile),然后在下方显示动态面板,同时没有蒙版,也就是在动态面板显示的同时,仍然可以操纵后面页面的其他元素,同时点击出动态面板外任意地方都可以关闭动态面板
- ==练习动态面板+蒙版的变式,值得回忆==
- 监听对象改为window,只要点击到window,就隐藏动态面板,不加蒙版
- 动态面板panel和其css样式省略,下面是js逻辑
  ```js
  // HeaderRight.jsx
  const HeaderRight = memo(() => {
      /** 定义组件内部状态 */
      // 控制Profile动态面板的显示和隐藏
      const [showPanel, setShowPanel] = useState(false)

      /** 副作用代码 */
      useEffect(() => {
        function windowHandleClick() {
          setShowPanel(false)
        }
        // 添加监听,第二个参数是捕获阶段监听,防止点击profile冒泡到window,误触发了隐藏panel的事件
        window.addEventListener('click', windowHandleClick, true)
        // 取消监听
        return () => {
          window.removeEventListener('click', windowHandleClick)
        }
      }, [])

      /** 事件处理函数 */
      function profileClickHandler() {
        setShowPanel(true)
      }

      return (
        <RightWrapper>
          <div className='profile' onClick={profileClickHandler}>
            <IconMenu />
            {
              showPanel && (
                <div className='panel'>
                  // .....
                </div>
              )
            }
          </div>
        </RightWrapper>
      )
    })
  ```
## 首页home
### 顶部轮播图
- 用第三方库做轮播图,Ant Design
- vite动态引入本地的图片不能直接用相对路径或字符串,如下显示,这是webpack底层打包的问题
  ```css
    background: url('@/assets/...');
    <img src='../../assets/...' />
  ```
- 无论是img还是url(),都可以引入图片作为变量使用
  ```js
    import styled from "styled-components";
    import coverImg from '@/assets/img/home/cover_01.jpeg' // 本地静态资源引入

    export const BannerWrapper = styled.div`
      height: 529px;
      background: url(${coverImg}) center/cover;
    `
  ```
  ```js
    <img src="{coverImg}" alt="" />
  ```
### 高性价比房源(*)
- ==做内容区content的房源菜单部分==, 高性价比房源api: http://codercba.com:1888/airbnb/api/home/goodprice
- ==服务器请求的数据放在redux中由store管理,而不是在单独的组件直接axios,在组件内发起网络请求,而执行请求的部分在redux中==
- ==1.创建对应的store/home.js(RTK)==
- ==axios网络请求, 处理异步数据, 保存state==
  ```js
    import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
    import { getHomeGoodPriceData } from "@/service";

    /** 异步请求数据的函数,记得导出 */
    export const fetchGoodPriceAction = createAsyncThunk('fetch/goodPriceData', async (payload) => {
      const res = await getHomeGoodPriceData()
      return res // .data已经在封装过了
    })

    const homeSlice = createSlice({
      name: 'home',
      initialState: {
        goodPriceInfo: {}
      },
      /** 保存异步数据->state */
      extraReducers: (builder) => {
        /** 处理成功信息 */
        builder.addCase(fetchGoodPriceAction.fulfilled, (state, {payload}) => {
          // console.log('extraReducer',payload)
          state.goodPriceInfo = payload
        })
        
        /** 处理错误信息 */
        builder.addCase(fetchGoodPriceAction.rejected, (state,action) => {
          if(state.err.message){
            console.log(action.error)
          } 
        })
      }
    })

    export default homeSlice.reducer
  ```
- 2.请求数据函数封装进service/modules/home
  ```js
    import hyRequest from "@/service";

    export function getHomeGoodPriceData(){
      return hyRequest.get({
        url: '/home/goodprice'
      })
    }
  ```
- 2.1记得导出home内部的函数
  ```js
    // service/index.js
    // 导出home内所有函数
    export * from './modules/home'
  ```
- 3.在views/home/index.jsx,派送请求并使用store
  ```js
      /** 从redux中获取数据 */
      const {goodPriceInfo} = useSelector((state) => ({
        goodPriceInfo: state.home.goodPriceInfo
      }), shallowEqual)

      /** 派发事件: 发送网络请求,不传参数 */
      const dispatch = useDispatch()
      useEffect(() => {
        dispatch(fetchGoodPriceAction())
      },[])

      return (
        <HomeWrapper>
          {/* 轮播图 */}
          <HomeBanner/>
          <div className='content'>
            <h2>{goodPriceInfo.title}</h2>
            <ul>
              {
                goodPriceInfo?.list?.map(item => {
                  return <li key={item.id}>{item.name}</li>
                })
              }
            </ul>
          </div>
        </HomeWrapper>
      )
  ```
### app-footer搭建(略)
- 使用codewhy老师的数据和样式,直接复制过来的,可以看看代码怎么写的,就是页面底部的内容,components/app-footer
- 数据在assets/data/footer.json中
### section-header
- 公用组件: 头部信息栏 section-header
- 创建命令: `rmcp`,创建可以接受props参数类型的组件,限制接受数据的类型
- 需要下载: `npm i prop-types` 
- 代码很简单,接受主标题和副标题,副标题可能没有,所以选择性显示
  ```js
    const SectionHeader = memo((props) => {
      // const {title,subtitle = '默认子标题'} = props
      const {title,subtitle} = props

      return (
        <HeaderWrapper>
          <h2 className='title'>{title}</h2>
          {subtitle && <div className='subtitle'>{subtitle}</div>}
        </HeaderWrapper>
      )
    })
  ```
### room-item(*)
- 配置内容区的每个房源Item数据,只展示前8个,在map遍历前用slice截取一下即可
- 每个room-item展示如下图
  [![pExnbLD.png](https://s21.ax1x.com/2025/05/20/pExnbLD.png)](https://imgse.com/i/pExnbLD)
- ==1.封装公共组件room-item, 给每个li的传入数据(itemData)==
  ```js
    // home/index.jsx
    <ul className='room-list'>
      {
        goodPriceInfo?.list?.slice(0,8).map(item => {
          return <RoomItem itemData={item} key={item.id} />
        })
      }
    </ul>
  ```
- ==2.组件room-item(类比li)与ul的css样式==
  - 后期组件有复用性,组件的宽度是变化的,有时候一行4个,有时候一行5个,对应width(25%/20%),所以不建议写死width是多少px
  - ==每个room-item都是左右间距8px,但是首尾没有间距,coderwhy老师提供了一个非常好的方法(简便)==
  - room-item(li)的css样式,先平等4分,然后怪异盒内pad 8px
    ```css
      width: 25%;
      padding: 8px;
      box-sizing: border-box;
    ```
  - ul的样式,保证flex布局和换行,把首位room-item多撑出来的pad,向内部的左右margin 8px
    ```css
      .room-list{
        margin: 0 -8px;
        display: flex;
        flex-wrap: wrap;
      } 
    ```
- ==3.解决图片比例不同的问题: 爱彼迎服务器给前端的图片的比例不同,导致同样设置width 100%,对应的图片高度不同==
    - cover提供占位,高为宽的2/3
    - img绝对定位把cover提供的占位占满
    ```css
       /* cover & img 保证图片大小一致
          html结构上,img是cover的子,子绝父相 */
      .cover {
        position: relative;
        box-sizing: border-box;
        padding: 66.66% 8px 0; /* 上 左右 下 */
        border-radius: 3px;
        overflow: hidden;

        img {
          position: absolute;
          left: 0;
          top: 0;
          width: 100%;
          height: 100%;
        }
      }
    ```
- ==没有图片img下,cover的占位示意图如下==
  [![pExnHsO.png](https://s21.ax1x.com/2025/05/20/pExnHsO.png)](https://imgse.com/i/pExnHsO)
  > 最后这个区域会被img覆盖,这样所有的图片大小就一致了
- ==4.额外的,服务器还传递额外的字体颜色数据,如何向css in js中传递变量,前面也学习了,如下==
- 需要注意的是,需要使用Transient Props($prefix)
  - ==通过在属性名前加 $ 前缀（例如 $color），可以明确告诉 styled-components：这个属性仅用于样式计算==
  - 防止这个属性被当作dom属性的一部分被加入,通常html标签会过滤这些无用的数据,但是建议不要这么做,react还会报警告
    ```jsx
    {/* room-item: 传递服务器变量数据, 这里记得加$ */}
    <ItemWrapper $verifyColor={itemData?.verify_info?.text_color || '#39576a'}>
      {/* ..... */}
    </ItemWrapper>
    ```
    > 新版本styled-components有兼容性问题,所以有警告
- 内部css in js通过props获取使用即可
  ```css
     .desc {
        margin: 10px 0 5px;
        font-size: 12px;
        font-weight: 700;
        /* 接受服务器传递的动态文字颜色,给属性前面记得加$ */
        color: ${props => props.$verifyColor};
      }
  ```
  > 这样css中的字体颜色可以动态更具服务器设置变化,同理别的属性都是这样
- 5.次要的内容
  - room-item内部小布局 div-inner, 简单的html和css布局, 略
  - 评分的星星 -> ui库 (后面再用,先略过)  
  - 配置了assets/css/common.css的一点样式,颜色和字体

### React-UI库(*)
- Ant和MUI两个组件库(Ant Design/Material),更加适用于后台管理系统
- ==1.MUI组件库安装==
  - ==**支持emotion或styled-components两种方式,但是对于SSR渲染强烈建议用emotion**==
  - **emotion**: `npm install @mui/material @emotion/react @emotion/styled`
  - **styled-components**: `npm install @mui/material @mui/styled-engine-sc styled-components`
- ==MUI默认支持emotion,所以使用styled-components需要额外的配置==
- 在vite.config.js中添加别名
  ```js
     module.exports = {
        //...
      +  resolve: {
      +    alias: {
      +      '@mui/styled-engine': '@mui/styled-engine-sc'
      +    },
      +  },
      }
  ```
  > 接下来可以使用MUI了
- ==**额外的,官方提供的兼容包@mui/styled-engine-sc可能因为和@mui/material版本不兼容问题导致失效,所以可以下载@mui/system代替**==
- 删除vite.config.js中的别名和卸载掉`@mui/styled-engine-sc`包
- 下载: `npm i npm install @mui/system`
- 完成上述一般可以运行了,如果还不行可以把emotion相关文档也下载下来,反正推荐
- ==2.集成Ant Design== 
- 下载`npm i antd`,直接使用即可,额外的,现在antv5版本需要安装兼容包兼容r19,在v6版本将会适配
- 兼容包下载: `npm install @ant-design/v5-patch-for-react-19 --save`
- 项目入口main.js引入 `import '@ant-design/v5-patch-for-react-19';`
- ==目前下来,可以根据要用的组件库单独引入使用即可,复制文档的引入==

### MUI_Rating
- 评分Rating组件(MUI组件库)
- 在room-item中,学习了Rating组件的一些属性,配置了点css样式(略)
  ```js
    import Rating from '@mui/material/Rating';

    {/* sx: 设置新的样式覆盖旧的样式 
        precision: 精准度,精确到0.1
        ??: 更加严谨,只有前面数据为Null或Undefined时才会执行后面的
        不使用'||'为了防止出现 0 || 4.5 => 4.5的情况,对0也默认执行后面
    */}
    <Rating
      value={itemData.star_rating ?? 4.5}
      precision={0.1}
      size="small"
      sx={{ fontSize: '12px', color: '#00848A' }}
      readOnly
    />
  ```
### section-rooms(略)
- 重构room-list封装进通用组件`section-rooms`,==注意获取数据的变化==
- 把之前的ul部分替代为组件,剩余不变
### 高评分房源
- 和高性价比的房源布局差不多, api: http://codercba.com:1888/airbnb/api/home/highscore
- 步骤: 
  - 1.封装对应的网络请求(老位置service),请求高分房源,代码略
  - ==2.多个异步数据请求RTK store/home.jsx==
    ```js
      /** 多个异步请求,不建议堆叠await,阻塞进程; 同时不建议写多个createAsyncThunk,维护困难
      *   还有第二个参数,action -> {getState,dispatch}
      *   getState可以获取initialState所有的状态,可以获取state使用,但是如果要修改state,必须通过action函数,不可以直接赋值修改!
      */
      export const fetchHomeDataAction = createAsyncThunk('fetchHomeData', async (payload, {dispatch}) => {
        getHomeGoodPriceData().then(res => {
          dispatch(changeGoodPriceInfoAction(res)) // 通过action修改state的值
        })
        getHomeHighscoreData().then(res => {
          dispatch(changeHighScoreInfoAction(res)) 
        })
      })

      const homeSlice = createSlice({
        name: 'home',
        initialState: {
          goodPriceInfo: {},
          highScoreInfo: {}
        },
        reducers: {
          changeGoodPriceInfoAction(state,{payload}){
            state.goodPriceInfo = payload
          },
          changeHighScoreInfoAction(state,{payload}){
            state.highScoreInfo = payload
          }
        }
      })
      // 记得导出action函数
      export const {
        changeGoodPriceInfoAction,
        changeHighScoreInfoAction
      } = homeSlice.actions
      export default homeSlice.reducer
    ```
    > 不再通过extraReducers处理异步数据赋值state,而是转用reducers
  - 3.home派发新的事件fetchHomeDataAction,同时获取store
    ```js
      /** 从redux中获取数据 */
      const { goodPriceInfo,highScoreInfo } = useSelector((state) => ({
        goodPriceInfo: state.home.goodPriceInfo,
        highScoreInfo: state.home.highScoreInfo
      }), shallowEqual)

      /** 派发事件: 发送网络请求,不传参数 */
      const dispatch = useDispatch()
      useEffect(() => {
        dispatch(fetchHomeDataAction())
      }, [])
    ```
    ```jsx
      <div className='content'>
        <div className='good-price'>
          <SectionHeader title={goodPriceInfo.title} />
          <SectionRooms roomList={goodPriceInfo.list} />
        </div>
        <div className='high-score'>
          <SectionHeader title={highScoreInfo.title} subtitle={highScoreInfo.subtitle} />
          <SectionRooms roomList={highScoreInfo.list}/>
        </div>
      </div>
    ```
- Redux请求如下:
    [![pEziyXd.png](https://s21.ax1x.com/2025/05/22/pEziyXd.png)](https://imgse.com/i/pEziyXd)
### HomeSectionV1
- 针对上面的高分/高性价比房源两个板块,封装进home部分组件home-section-v1
- ==接受房源数据==,然后内部渲染即可,css配置等略
  ```jsx
    import SectionHeader from '@/components/section-header'
    import SectionRooms from '@/components/section-rooms'

    const HomeSectionV1 = memo((props) => {
      const {infoData} = props
      return (
        <SectionV1Wrapper>
          <SectionHeader title={infoData.title} subtitle={infoData.subtitle}/>
          <SectionRooms roomList={infoData.list}/>
        </SectionV1Wrapper>
      )
    })

    HomeSectionV1.propTypes = {
      infoData: PropTypes.object
    }
  ```
- 主页面home,只需简单传参即可
  ```jsx
    <div className='content'>
      <HomeSectionV1 infoData={goodPriceInfo}/>
      <HomeSectionV1 infoData={highScoreInfo}/>
    </div>
  ```
### 折扣与item动态宽度(*)
- 折扣数据的api接口: http://codercba.com:1888/airbnb/api/home/discount
- ==继续遵循前面的步骤(代码略)==
  - 1.service新增网络请求
  - 2.store中请求action和store数据整理
- ==重点学习传递动态width==
- 动态处理房屋列表的宽度,有的一行3个,有的一行4个,有的一行5个,单独写麻烦,通过动态width来控制
- 公共组件room-item,==之前在这个章节也对verifyColor做了相同处理,有笔记==
  ```jsx
     <ItemWrapper 
        $verifyColor={itemData?.verify_info?.text_color || '#39576a'} 
        $itemWidth={itemWidth}
      >
        // .....
     <ItemWrapper/>
  ```
  ```js
    export const ItemWrapper = styled.div`
      width: ${props => props.$itemWidth};
    `
  ```
  > 传递动态itemWidth,组件套组件,一层层传递props即可
### 折扣数据选项卡
- ==选项卡tabs的封装成公共组件section-tabs,许多地方会复用==
- 需要下载: `npm i classnames`,更加方便的添加class属性
- 1.选项卡案例经常用到,找到点击标签和当前标签进行比较,css略
  ```jsx
      const SectionTabs = memo((props) => {
      const {tabTitles = []} = props
      const [currentIndex,setCurrentIndex] = useState(0)
      
      function itemClickHandle(index){
        setCurrentIndex(index)
      }

      return (
        <TabsWrapper>
          {
            tabTitles.map((item,index) => {
              return (
                <div 
                  className={classNames('item',{active: index === currentIndex})} 
                  key={index}
                  onClick={e => itemClickHandle(index)}
                >
                  {item}
                </div>
              )
            })
          }
        </TabsWrapper>
      )
    })

    // 接受传入的标题列表
    SectionTabs.propTypes = {
      tabTitles: PropTypes.array
    }
  ```
- 2.SectionTabs切换与内容的数据切换联动,==子传父,记得useCallback优化==
- 2.1父组件home.jsx向子组件SectionTabs传递回调函数tabClickHandle,动态改变name的值,从而渲染新的选项卡数据
    ```js
      // 初始化第一次要渲染的SetionRooms数据
      const [name,setName] = useState('佛山')
      /** 回忆useCallback的优化作用 */
      const tabClickHandle = useCallback(function(index,name) {
        setName(name)
      },[])
    ```
    ```jsx
      <div className='discount'>
          <SectionHeader title={discountInfo.title} subtitle={discountInfo.subtitle} />
      ->  <SectionTabs tabTitles={tabTitles} tabClick={tabClickHandle}/>
      ->  <SectionRooms roomList={discountInfo.dest_list?.[name]} itemWidth = '33.33333%'/>
      </div>
    ```
- 2.2子传父,传递当前点击选项卡的name属性,SectionTabs->home.jsx
  ```js
    const {tabTitles = [], tabClick} = props
    function itemClickHandle(index,item){
      setCurrentIndex(index)
      // index是索引,item是值(name)
      tabClick(index,item)
    }
  ```
  ```jsx
    <div 
      className={classNames('item',{active: index === currentIndex})} 
      key={index}
  ->  onClick={e => itemClickHandle(index,item)}
    >
      {item}
    </div>
  ```
### HomeSectionV2
- 封装折扣房屋数据进入home的cpns组件,和HomeSectionV1一样
- 接受infoData数据,内部数据处理和渲染照搬之前的代码,如下
  ```jsx
    const HomeSectionV2 = memo((props) => {
      /** 接受props */
      const {infoData} = props
      /** 定义本地state和处理数据 */
      const [name,setName] = useState('佛山') 
      const tabTitles = infoData.dest_address?.map(item => item.name) 
      /** 事件处理函数 */
      const tabClickHandle = useCallback(function(index,name) {
        setName(name)
      },[])

      return (
        <SectionV2Wrapper>
          <div className='discount'>
            <SectionHeader title={infoData.title} subtitle={infoData.subtitle} />
            <SectionTabs tabTitles={tabTitles} tabClick={tabClickHandle}/>
            <SectionRooms roomList={infoData.dest_list?.[name]} itemWidth = '33.33333%'/>
          </div>
        </SectionV2Wrapper>
      )
    })

    HomeSectionV2.propTypes = {
      infoData: PropTypes.object
    }
  ```
### 初始化数据
- 选项卡name数据初始化如何做? 这个组件要复用多次,不可以永远是佛山
- ==思路: 先初始化useState数据,因为是异步数据,所以初始为空值; 等到异步数据请求下来后,再传递新的值给state==
  ```js
    /** 接受props */
    const {infoData} = props
    /** 定义本地state和处理数据 */
    const initialName = Object.keys(infoData?.dest_list ?? {})[0] ?? ""
    const [name,setName] = useState(initialName) 
  ```
  > ?? 是比 || 更细致的,不会被数字0误导,当前面为Null/undefined时才会执行后面
  > 1.第一个??是针对内部数据infoData?.dest_list为空时,默认初始化为{}
  > 2.第二个??是针对外部数据,当内部初始化为空,则有 Object.keys({})[0] -> [][0] -> undefined,所以继续初始化为""
- ==useState特性==: 只有第一次数据初始化有效,后续更新无效,针对异步数据请求的数据,其实已经晚了,第一次在初始化数据时,useState已经定死了,不会再改变了
- ==解决==: 控制第一次渲染的时机 {判断条件 && 组件}
  ```jsx
    // 父组件上,先决定要不要渲染tabs组件,如下
    { Object.keys(discountInfo).length && <HomeSectionV2 infoData={discountInfo}/>}
  ```
- 同时这样保证HomeSectionV2渲染时infoData一定是有数据的,所以内部的多个`??`可以删除
  ```js
    /** 接受props */
    const {infoData} = props
    /** 定义本地state和处理数据 */
    const initialName = Object.keys(infoData.dest_list)[0]
    const [name,setName] = useState(initialName) 
    const tabTitles = infoData.dest_address?.map(item => item.name)
  ```
  > 直接获取到infoData数组的第一项作为name,codewhy老师这里数据整理的很好,一般后端的数据是很杂乱的,如何处理好数据是前端高效渲染数据的前提
- ==把判断数据长度的函数封装进入utils,给HomeSectionV1也用上==
  ```jsx
    { isEmptyObj(discountInfo) && <HomeSectionV2 infoData={discountInfo}/> }
    { isEmptyObj(goodPriceInfo) && <HomeSectionV1 infoData={goodPriceInfo}/>}
    { isEmptyObj(highScoreInfo) && <HomeSectionV1 infoData={highScoreInfo}/>}
  ```
  > 其实这样也减少一次渲染,原来的组件第一次渲染,传入的infoData是空的(异步),所以内部使用的是初始化的值,但是后面异步请求数据到达后,再传入infoData,组件内部props发生改变,又会渲染一次;
  > 做过判断后,组件只会渲染一次,那就是只有当数据请求到达后,渲染一次
### 热门数据(略)
- 数据接口: http://codercba.com:1888/airbnb/api/home/hotrecommenddest
- 这个部分和折扣房源一样,可以复用
  - 1.service请求封装
  - 2.存储store
  - 3.直接应用到页面
- react高手,封装的好的react代码是这样的
  ```jsx
    <div className='content'>
      { isEmptyObj(discountInfo) && <HomeSectionV2 infoData={discountInfo}/> }
      { isEmptyObj(recommendInfo) && <HomeSectionV2 infoData={recommendInfo}/> }

      { isEmptyObj(goodPriceInfo) && <HomeSectionV1 infoData={goodPriceInfo}/>}
      { isEmptyObj(highScoreInfo) && <HomeSectionV1 infoData={highScoreInfo}/>}
    </div>
  ```
### section-footer
- 封装区域的公共组件section-footer,比如展示全部,显示图片等
- section-home-v1/v2都有section-footer,但是添加内容不同
- 提供name(props)作为内容的父传子入口(v2),如果没有传入name则用默认样式(v1)

### Tabs滚动封装(*)
- 滚动由transform/translate()实现,不再使用默认的滚动方式
- 动态计算选中tab距离左侧的宽度,不同的滚动条tab宽度不一,也就是说滚动的tab内容宽度我们也不能确定
- ==封装scroll-view组件(更加通用,封装进base-ui),左右侧滚动按钮+滚动的逻辑展示+展示内容由外界传入(如下)==
  ```jsx
    <TabsWrapper>
      <ScrollView>
        {/* 往组件的插槽传入内容 */}
        {
          tabTitles.map((item, index) => {
            // ....
          })
        }
      </ScrollView>
    </TabsWrapper>
  ```
- ==**1.右边按钮显示逻辑: 内容长度是否大于展示长度**==
  [![pEzis6H.png](https://s21.ax1x.com/2025/05/22/pEzis6H.png)](https://imgse.com/i/pEzis6H)
  ```js
    const totalDistanceRef = useRef() // 保证组件多次渲染下,内部值不会变化

    /** 组件渲染完毕,判断是否加载右侧按钮 */
    const scrollContentRef = useRef() // 获取滚动条的dom对象
    useEffect(() => {
      const scrollWidth = scrollContentRef.current.scrollWidth // 一共可以滚动的长度
      const clientWidth = scrollContentRef.current.clientWidth // 本身占据宽度
      const totalDistance = scrollWidth - clientWidth // 可滚动长度
      totalDistanceRef.current = totalDistance // 记录一下,按钮滚动逻辑函数要用
      setShowRight(totalDistance > 0) // 如果可滚动长度大于0自动设置showRight为true
    },[props.children]) // 如果传入的tabs内容改变,重新判断上面的逻辑
  ```
- ==**2.点击右侧按钮滚动**==
  - 滚动区间长度 (注意tabs的每个item宽度不一定相等,所以不能随便取item作为通用滚动间距)
  - 再次判断是否显示右侧按钮
  [![pEzicnA.png](https://s21.ax1x.com/2025/05/22/pEzicnA.png)](https://imgse.com/i/pEzicnA)
  ```js
    const [showRight,setShowRight] = useState(false) // 右侧按钮显示
    const [showLeft,setShowLeft] = useState(false) // 左侧按钮显示
    const [posIndex,setPosIndex] = useState(0) // 当前item索引(待)

    function rightClickHandle() {
      const newIndex = posIndex + 1
      const newEl = scrollContentRef.current.children[newIndex]
      const newElOffsetLeft = newEl.offsetLeft // offsetLeft: 忘记了就搜索MDN,只读属性,当前子元素在其父定位元素内向左偏移的像素数
      scrollContentRef.current.style.transform = `translate(-${newElOffsetLeft}px)` // 向左偏移
      console.log(newElOffsetLeft)
      setPosIndex(newIndex) // 更新新的item索引
      /** 是否显示右侧按钮: 不显示 -> ElOffsetLeft(向左滚动距离) > totalDistance(剩余可滚动长度) 
       *  totalDistance可以设置useState,但是没必要,因为我们只是要记录它的值,在下面进行比较而已,但是如果使用setTotalDistance会使得整个组件重新渲染
      *  所以使用useRef记录它的值,同理posIndex也是(待)
      */
      setShowRight(totalDistanceRef.current > newElOffsetLeft)
      setShowLeft(newElOffsetLeft > 0) // 只要左边有滚动距离就显示'左侧'按钮
    }
  ```
  > ==附: 1.代码最后一行其实是处理左侧按钮显示的代码,因为逻辑太简单,所以不单独列出了==
- ==**3.同理左边的按钮是类似逻辑,所以把左右的按钮逻辑封装为一个函数**==
  ```js
    /** 事件处理函数 */
    function controlClickHandle(isRight){
      const newIndex = isRight ? posIndex + 1 : posIndex - 1 // 只有这里变了,需要判断左/右按钮
      const newEl = scrollContentRef.current.children[newIndex]
      const newElOffsetLeft = newEl.offsetLeft 
      scrollContentRef.current.style.transform = `translate(-${newElOffsetLeft}px)` 
      setPosIndex(newIndex) 
      setShowRight(totalDistanceRef.current > newElOffsetLeft)
      setShowLeft(newElOffsetLeft > 0) 
    }
  ```
- 4.左右svg引入+css样式(直接复制的,略微改变html结构,略)
  ```jsx
    <ViewWrapper>
      { showLeft && 
        <div className='control left' onClick={e => controlClickHandle(false)}>
          <LeftArrowIcon/>
        </div>
      }
      { showRight && 
        <div className='control right' onClick={e => controlClickHandle(true)}>
          <RightArrowIcon/>
        </div>
      }
      {/* 插槽: 展示的内容 */}
      <div className='scroll'>
        <div className='scroll-content' ref={scrollContentRef}>
            {props.children}
        </div>
      </div>
    </ViewWrapper>
  ```
### 向往数据封装
- ==借助上面封装的tabs组件==,请求'你可能想去'的数据,然后展示,十分简单
- 数据接口: http://codercba.com:1888/airbnb/api/home/longfor
- 效果图如下:
  [![pEzyUtH.png](https://s21.ax1x.com/2025/05/23/pEzyUtH.png)](https://imgse.com/i/pEzyUtH)
- 1.数据请求(server)
- 2.store处理 + home.jsx派发请求
- 3.在home/cpns,创建新组件HomeLongFor,接受请求的数据,由home.jsx父传子
- 4.构建HomeLongFor内部,获取tab数组,新建longfor-item,接受tab数组的每个item,然后构建它们的样式(复制coderwhy)
- 5.配置好HomeLongFor和longfor-item的样式后,直接使用ScrolView组件搞定左右按钮+滚动逻辑
  ```jsx
    // HomeLongFor 
    <div className='longfor-list'>
      <ScrollView>
        {
          infoData.list.map(item => {
            return <LongForItem itemData={item} key={item.city} />
          })
        }
      </ScrollView>
    </div>
  ```
  ```jsx
    // longfor-item
    <ItemWrapper>
      <div className='inner'>
        <img className='cover' src={itemData.picture_url} alt="" />
        {/* bg-cover: 蒙版,加深了图片的颜色 */}
        <div className='bg-cover'></div>
        <div className='info'>
          <div className='city'>{itemData.city}</div>
          <div className='price'>均价: {itemData.price}</div>
        </div>
      </div>
    </ItemWrapper>
  ```
### Plus数据封装(略)
- 同理轮播封装,数据接口: http://codercba.com:1888/airbnb/api/home/plus
- 同理 service->store->home.jsx->HomeSectionV3组件->RoomItem组件
- 和前面向往的数据没有任何区别,并且可以直接复用RoomItem组件,不用自己写Item组件
- ==所有的代码略==

### '更多'页面跳转
- 给SectionFooter添加跳转逻辑,使用useNavigate(Hooks),同时跳转到`/entire`
  ```js
    /** 事件处理函数 */
    const navigate = useNavigate()
    function moreClickHandle(){
      navigate('/entire')
    }
    
    return (
      <FooterWrapper name={name}>
        <div className='info' onClick={moreClickHandle}>
          <div className='text'>{showMessage}</div>
          <IconMoreArrow />
        </div>
      </FooterWrapper>
    )
  ```
## 详情页entire
- ==entire页介绍==
  - 顶层-过滤功能(filter),选择对应的房源类型在下面的内容区显示对应的房源内容
  - 底层-分页器(pagination): 套用UI库
  - 中间-内容数据: 内容Item图片还有轮播功能,轮播点显示不同,小细节较多
- 按照组件把三个部分封装进`/entire/cpns`
### EntireFilter
- 模拟的分类数据在`/assets/data/filter_data.json`,只是简单模拟
- 先搭建简单的样式模板(复制codewhy)
- 1.先做点击的基础逻辑
  - ==多选==
  - ==第二次点击则取消选中状态==
    ```js
      /** 状态管理 */
      const [selectItems,setSelectItems] = useState([])

      /** 事件处理逻辑 */
      function itemClickHandle(item){
        const newItems = [...selectItems] // 不可以在原state上修改
        if(newItems.includes(item)){ // 有数据就删除
          const itemIndex = newItems.findIndex(filterItem => filterItem === item)
          newItems.splice(itemIndex,1)
        }else{ // 没有数据就添加
          newItems.push(item)
        }
        // 更新选中的数组
        setSelectItems(newItems)
      }
    ```
- 2.添加class(active),==依靠classNames库==
  ```jsx
    <div className='filter'>
      {
        filterData.map((item,index) => {
          return (
            <div
              className= {classNames('item', {active: selectItems.includes(item)})}
              key={index}
              onClick={e => itemClickHandle(item)}
            >
              {item}
            </div>
          )
        })
      }
    </div>
  ```
### EntireRooms
- 展示内容区: 请求数据保存到redux中, ==**entire模块使用是原版redux(无toolkit),代码略,忘了回去回顾**==
- 接口: `http://codercba.com:1888/airbnb/api/entire/list?offset=0&size=20`,==参数offset为偏移量(不是页数),size为请求数据个数==
- ==1.配置新的网络请求==`service/modules/entire`
  ```js
    import hyRequest from "..";

    export function getEntireRoomList(offset = 0,size = 20){
      return hyRequest.get({
        url: '/entire/list',
        params: {
          offset,
          size
        }
      })
    }
  ```
- ==2.网络请求在redux内部,在createAction文件内==
  ```js
    export const fetchRoomListAction = () => {
      return async (dispatch,getState) => {
        /** 根据页码获取请求的偏移量 (一页20个数据)
         *  之后通过分页器控制currentPage的值,从而控制请求数据的偏移量,实现分页器和内容的联动
         *  点击对应的页数,请求对应页的数据并显示
        */
        const currentPage = getState().entire.currentPage
        const res = await getEntireRoomList(currentPage * 20)
        // 将获取的数据保存进store中
        const roomList = res.list
        const totalCount = res.totalCount
        dispatch(changeRoomListAction(roomList))
        dispatch(changeTotalCountAction(totalCount))
      }
    }
  ```
- ==3.派发网络请求事件,由entire主页面派发==
  ```jsx
    const Entire = memo(() => {
      const dispatch = useDispatch()
      useEffect(() => {
        dispatch(fetchRoomListAction())
      },[dispatch]) // dispatch一般不变,等同于[]

      return (
        <EntireWrapper>
          <EntireFilter/>
          <EntirePagination/>
          <EntireRooms/>
        </EntireWrapper>
      )
    })
  ```
- ==4.页面的搭建,复用之前的组件,样式很简单,略==
  ```jsx
    /** 从redux中获取数据 */
    const {roomList,totalCount} = useSelector((state) => ({
      roomList: state.entire.roomList,
      totalCount: state.entire.totalCount
    }),shallowEqual)

    return (
      <RoomsWrapper>
        <h2 className='title'>共{totalCount}住处</h2>
        <div className='list'>
          {
            roomList.map(item => {
              return (
                <RoomItem itemData={item} itemWidth='20%' key={item.id} />
              )
            })
          }
        </div>
      </RoomsWrapper>
    )
  ```
### pagination
- 使用ui组件库--MUI: 前面已经引入了此组件库
- 1.修改分页器颜色样式(不使用默认提供)
  - 一: 样式的更改,通过theme+provider提供自己定义的主题色(略,前面也用过)
  - ==二: 观察css样式名字,选择添加css覆盖,通过调试工具点击对应元素观察class名字==
    ```css
      /* 单个分页器的样式 */
      .MuiPaginationItem-page{
        &:hover{
          text-decoration: underline;
        }
      }
      /* 分页器+选中状态下的样式 */
      .MuiPaginationItem-page.Mui-selected{
        color: #fff;
        background-color: #222;
      }
    ```
- 2.分页器的数据显示,2个小算法,数据区间和总页数等
  ```jsx
    const { totalCount, currentPage, roomList } = useSelector((state) => ({
      totalCount: state.entire.totalCount,
      currentPage: state.entire.currentPage,
      roomList: state.entire.roomList
    }),shallowEqual)

    const startCount = currentPage * 20 + 1
    const endCount = (currentPage + 1) * 20
    const totalPage = Math.ceil(totalCount / 20) // 总页数: 向上取整,例如 305/20=15.XXX -> 16

    return (
      <PaginationWrapper>
        {/* 当请求不到数据时,roomList.length显示为0,转为布尔值,不要显示在页面上 */}
        {
          !!roomList.length && (
            <div className='info'>
              <Pagination count={totalPage} />
              <div className='desc'>
                {/* 算法: currentPage * 20 + 1 ~ (currentPage + 1) * 20 
                      currentPage: 0  1 - 20 
                      currentPage: 1  21 - 40 
                */}
                第{startCount}-{endCount}个房源,共超过{totalCount}个
              </div>
            </div>
          )
        }
      </PaginationWrapper>
    )
  ```   
- 3.点击分页器页码切换数据,==看文档找监听事件`onChange`==
- 额外的小细节: 切换新的页面时,跳转到顶部
  ```jsx
    /** 事件处理逻辑 */
    // 默认传递2个参数,默认事件/页码数
    const dispatch = useDispatch()
    function PageChangeHandle(evt,pageCount){
      // 跳转到顶部
      window.scrollTo(0,0)
      // 1.更新最新页码->redux: currentPage
      dispatch(changeCurrentPageAction(pageCount - 1))
      // 2.根据最新的页码请求新的页面数据
      dispatch(fetchRoomListAction())
    }

    <Pagination count={totalPage} onChange={PageChangeHandle} />
  ```
### 蒙版和isLoading
- 1.加载蒙版: 在entire-rooms的基础上加的,覆盖整个数据内容区域,==留意一下less样式,代码略==
- ==2.isLoading的逻辑==: 发送网络请求时为true,网络请求结束后为false,封装进redux/entire,然后在这个页面获取store内的isLoading(==代码略==)
  - 爱彼迎网站的isLoading仅在这个页面使用了,并没有在所有地方使用,所以不必在axios拦截器上挂载
  - 如果要在axios拦截器上使用它,无法通过hooks获取到dispatch,需要引入store,再从store中拿取dispatch方法  
    ```jsx
      {/* 蒙版 */}
      {isLoading && <div className='cover'></div>}
    ```
### RoomItem轮播效果(*)
- 单个RoomItem的轮播效果`/components/room-item`
- ==MUI是没有轮播图的,而antd的轮播图也是借助第三方库二次加工的
- 专业的react轮播图第三方库: `https://react-slick.neostack.com/docs/get-started`==
- 1.轮播图的基本布局
  ```jsx
    <div className='swiper'>
      <div className='control'>
        {/* 轮播图 */}
        <Carousel dots={false}>
          {
            itemData?.picture_urls.map(item => {
              return (
                <div className='cover' key={item}>
                  <img src={item} alt="" />
                </div>
              )
            })
          }
        </Carousel>
      </div>
  ```
  > picture_urls 是爬取的轮播图片数组
- ==**2.使用轮播图并自定义样式**==
  - 1.箭头样式自定义,箭头是svg图片后面会详细学习,可以动态传参修改svg的大小和颜色,svg的颜色可以继承父元素的字体颜色`color`属性
    ```jsx
    const IconArrowLeft = memo((props) => {
      const {width = 12,height = 12} = props
      return (
        <svg viewBox="0 0 18 18" role="img" aria-hidden="false" aria-label="previous" focusable="false" style={styleStrToObj(`height: ${height}px; width: ${width}px; display: block; fill: currentcolor;`)}><path d="m13.7 16.29a1 1 0 1 1 -1.42 1.41l-8-8a1 1 0 0 1 0-1.41l8-8a1 1 0 1 1 1.42 1.41l-7.29 7.29z" fillRule="evenodd"></path></svg>
      )
    })
    ```
    ```jsx
      <IconArrowLeft width='30' height='30'/>
    ```
    > ==以左箭头为例`assets/svg/icon-arrow-left`,接受props参数传入css样式的模板字符串==
  - 2.箭头绝对定位至左右两侧,箭头居中且有两个大的背景版,背景板有渐变阴影,鼠标:hover时和箭头一起显示,如下图
    [![pVSffA0.png](https://s21.ax1x.com/2025/05/26/pVSffA0.png)](https://imgse.com/i/pVSffA0)
    > 样式和jsx结构复制codewhy老师代码,代码略
  - 3.给箭头添加跳转逻辑,==通过ref获取antd组件的dom对象,然后获取dom对象内部的方法(方法看文档)==
    ```js
      // 获取到轮播图的dom对象
      const swiperRef = useRef()

      /** 事件处理逻辑 */
      // 1.跳转上一个/下一个面板
      function controlClickHandle(isRight = true){
        if(isRight){
          swiperRef.current.next()
        }else{
          swiperRef.current.prev()
        }
      }
    ```
    ```jsx
      <Carousel dots={false} ref={swiperRef}>
        // ...
      </Carousel>
    ```
### 封装指示器(*)
- ==**锻炼封装,算法能力和一些css基础属性的理解**==
- 自定义指示器的特点,指示器会显示5个点,被点击的轮播item指示器高亮且居中,滚动到边缘就不会居中了
- ==可以先写一个demo,封装为一个组件,然后引入到项目中使用,不建议一开始就和项目结合,这样干扰因素较多,且不一定具有通用性==
- 封装进`/base-ui/indicator` 测试页面`/views/demo`
- ==1.1基础结构,`demo`==
  ```jsx
    const Demo = memo((props) => {
      const names = ['aaa','vvv','bbb','dxs','sde','www','fff','sss']
      const [selectIndex,setSelectIndex] = useState(0) // 记录选中的索引

      /** 事件处理函数 */
      function toggleClickHandle(isNext=true){ // 上/下一个函数
        let newIndex = isNext ? selectIndex + 1 : selectIndex - 1
        if(newIndex < 0) newIndex = names.length - 1
        if(newIndex > names.length - 1) newIndex = 0
        setSelectIndex(newIndex)
      }

      return (
        <DemoWrapper>
          <div className='control'>
            <button onClick={e => toggleClickHandle(false)}>上一个</button>
            <button onClick={e => toggleClickHandle()}>下一个</button>
          </div>
          <div className='list'>
            <Indicator selectIndex={selectIndex}>
              {
                names.map((item,index) => {
                  return <button key={index}>{item}</button>
                })
              }
            </Indicator>
          </div>
        </DemoWrapper>
      )
    })
  ```
  > 1.提供测试数据names
  > 2.提供功能按钮 上一个/下一个, 简单的逻辑和边界检测,是对轮播图数组的检测,需要传入组件,指示器组件需要知道当前轮播到哪一个索引了
  > 3.==自封组件内部是一个插槽,需要把轮播内容放进去,十分灵活,指示器组件没有要求内容的限制,一般来说是指示器小圆点,但是你如果愿意可以放小图片进去,调整好样式即可==
  > 4.css样式略,对轮播图的宽度做限制,为后续多个指示器溢出隐藏做准备
- ==1.2基础结构`indicator`==
  ```jsx
    const Indicator = memo((props) => {
      const {selectIndex = 0} = props

      return (
        <IndicatorWrapper>
        {/* 插槽,接受指示器的数据展示,可以是任意的元素,小图标,大图片,数字,按钮,div等等; 封装的组件具有通用性,你传入什么作为指示器都可以 */}
          <div className='i-content' ref={contentRef}>
            {
              props.children
            }
          </div>
        </IndicatorWrapper>
      )
    })
  ```
- ==2.滚动逻辑(中心点位置)==: 优先实现,每一个轮播item都可以居中,后期再做边缘特殊处理
- ==2.1滚动中心的算法效果图== 轮播条滚动,内部5个item,indicator是静止的(overflow: hiddlen; 溢出的滚动条看不到)
  [![pVSf2Bn.png](https://s21.ax1x.com/2025/05/26/pVSf2Bn.png)](https://imgse.com/i/pVSf2Bn)
- ==**依据计算公式提供下列代码**== 
  ```js
     // 1.获取选中的元素
    const selectItemEl = contentRef.current.children[selectIndex]
    const itemLeft = selectItemEl.offsetLeft // 获取offsetLeft记得给父元素加定位(relative)
    const itemWidth = selectItemEl.clientWidth // 选中item宽度
    const contentWidth = contentRef.current.clientWidth // indicator宽度(也是轮播的可视区域)
    const contentScroll = contentRef.current.scrollWidth // 总共可以移动的距离(包含溢出隐藏的部分,即整个轮播长度)
    // 2.最终要滚动的宽度,根据算法效果图 
    let distance = itemLeft + itemWidth * 0.5 - contentWidth * 0.5
  ```
- ==2.2不可居中的特殊效果图(左侧和右侧情况)==
- 正常居中与左侧特殊情况,如下图
  [![pVSfgns.png](https://s21.ax1x.com/2025/05/26/pVSfgns.png)](https://imgse.com/i/pVSfgns)
- 在添加一段代码,体现移动transition
  ```js
    // 4.向左边滚动,负号写在${}里面作为js代码会计算(比如负负得正)
    // 写在外面当作字符串就只会拼接,计算会出错误
    contentRef.current.style.transform = `translate(${-distance}px)` 
  ```
  > contentRef是通过useRef获取的轮播图dom对象,控制轮播图在indicator中的偏移移动量
- ==解决左侧偏移问题==
  ```js
    // 当dis为负数带入公式 ${-dis}px -> 正数 -> 向右移动居中, 说明左侧会空出一块空白 
    if(distance < 0) distance = 0 // 3.1 左边特殊情况
  ```
  > 当dis<0时,会造成轮播图向右移动,此时置为零,不再偏移
- ==同理解决右侧问题,效果图如下==
  [![pVSfR7q.jpg](https://s21.ax1x.com/2025/05/26/pVSfR7q.jpg)](https://imgse.com/i/pVSfR7q)
- 即当轮播到最后面几个图片(3,4),就不可以居中显示了,否则右侧会出现空白,判断的依据是,当Dis+indicator > 整个轮播内容宽度时(scrollWidth),右侧会出现空白,所以dis不可以超出上述图片dis的值,限制了dis的最大值
  ```js
    // 当dis运动距离大于总共可移动距离时,让其等于最大移动距离,否则右侧会有空白,必须结合效果图理解!
    if(distance > totalDistance) distance = totalDistance // 3.2 右边特殊情况
  ```
- ==**总结: 计算公式核心如上,还有知识点,重新看代码,这里把代码拆分了,重点讲了封装算法的问题,其他的小细节也很重要**==
  - react的插槽如何表达(2个方法): prop.children
  - 在组件中,如何通过selectIndex获取被选中的item: useRef获取dom对象 
  - 组件内部的css样式,为什么要定位问题: 获取offsetLeft相对的是父定位元素
  - 组件内css样式: 有使用`> *`(所有的亲子孩子,不涉及后代),还有不压缩的属性`shrink` (后续显示固定个数指示器,不会压缩,溢出的隐藏)
  - useEffect参照的变量: selectIndex
- ==额外: 熟悉一下scrollWidth offsetLeft clientWidth,忘记了多研究== 
  - 代码中涉及这几个变量的计算dom对象为contentRef,如下
    ```jsx
      <IndicatorWrapper>
        {/* 插槽,接受指示器的数据展示,可以是任意的元素,小图标,大图片,数字,按钮,div等等; 封装的组件具有通用性,你传入什么作为指示器都可以 */}
        <div className='i-content' ref={contentRef}>
          {
            props.children
          }
        </div>
      </IndicatorWrapper>
    ```
    > ==dom获取的对象是div,在计算图中这是indicator,显示宽度有限制,溢出会隐藏==
    > 内部的插槽内容是轮播图,对应计算图中的蓝色长条,长度大于indicator,溢出会隐藏
  - scrollWidth是整体的宽度,包含溢出隐藏的部分,上面用这个属性获取到了整个轮播图的长度
  - clientWidth是可视范围内的宽度,不涉及溢出隐藏,仅包含content,padding和滚动条(自动添加的), 而不包含border margin,所以这部分是上述橙色长条部分
  - offsetLeft是子元素相对于定位父元素(如果没有往上一级找,直到body)的左侧偏移量
- 效果图如下: 
  [![pVShwr9.png](https://s21.ax1x.com/2025/05/26/pVShwr9.png)](https://imgse.com/i/pVShwr9)
### 应用指示器
- ==把封装好的indicator应用于页面中==`/components/room-item`
  ```jsx
    const [selectIndex, setSelectIndex] = useState(0)

    <div className='swiper'>
        {/* indicator自定义指示器 */}
        <div className='indicator'>
          <Indicator selectIndex={selectIndex}>
            {
              itemData?.picture_urls?.map((item, index) => {
                return (
                  <div className='item' key={item}>
                    <span className={classNames("dot", { active: selectIndex === index })}></span>
                  </div>
                )
              })
            }
          </Indicator>
        </div>
    </div>
  ```
  > 1.css直接复制的codewhy老师,也要看,把indicator定位到了轮播图的指定位置
  > 2.轮播内容是一组图片数组
### 不同页面的展示(*)
- 小细节: room-item被entire和home页面共同使用,所以是否显示轮播图要看看这个页面有没有轮播图的关键信息`itemData.picture_urls`
- ==提供一个简单的思路,首先把要显示的两种类型的jsx元素封装好==
  ```jsx
    // 没有轮播图,单图html (例如 /home)
    const pictureElement = (
      <div className='cover'>
        <img src={itemData.picture_url} alt="" />
      </div>
    )

    // 有轮播图html (例如 /entire)
    const swiperElement = (
      <div className='swiper'>
        {/* 左右箭头 */}
        <div className='control'>
          <div className='btn left' onClick={e => controlClickHandle(false)}>
            <IconArrowLeft width='30' height='30' />
          </div>
          <div className='btn right' onClick={e => controlClickHandle()}>
            <IconArrowRight width='30' height='30' />
          </div>
        </div>
        {/* indicator自定义指示器 */}
        <div className='indicator'>
          <Indicator selectIndex={selectIndex}>
            {
              itemData?.picture_urls?.map((item, index) => {
                return (
                  <div className='item' key={item}>
                    <span className={classNames("dot", { active: selectIndex === index })}></span>
                  </div>
                )
              })
            }
          </Indicator>
        </div>
        {/* 轮播图 */}
        <Carousel dots={false} ref={swiperRef}>
          {
            itemData?.picture_urls?.map(item => {
              return (
                <div className='cover' key={item}>
                  <img src={item} alt="" />
                </div>
              )
            })
          }
        </Carousel>
      </div>
    )
  ```
- ==然后根据轮播图数据,判断到底渲染哪一个jsx==
  ```js
    {/* 判断是不是轮播图样式的item,只需判断itemData.picture_urls有没有值 */}
    { itemData.picture_urls ? swiperElement : pictureElement }
  ```
### 跳转详情页(*)
- ==1.不同情况下的跳转许可==
- 针对room-item 不同的页面要求不同,home页面不可以跳转,而entire页面可以跳转
- ==思路: 点击room-item的函数由父元素传递,这样home或entire使用room-item组件时可以根据传递的函数实现不同的效果==
  ```jsx
    // room-item
    const {itemClick} = props
    // 接受传入的跳转函数,如果有传入就执行,没有传入就不执行任何事情
    function itemClickHandle(){
      if(itemClick) itemClick(itemData)
    }
    <ItemWrapper onClick={itemClickHandle}></ItemWrapper>
  ```
  ```jsx
    // entire
    const navigate = useNavigate()
    const itemClickHandle = useCallback((itemData) => {
      navigate('/detail')
    },[])

    roomList.map(item => {
      return (
        <RoomItem itemData={item} itemClick={itemClickHandle} />
      )
    })
  ```
  > 1.父传子一个函数,在孩子组件的点击事件中优先判断是否有传入函数,如果有就执行,没有就不执行
  > 2.entire组件在使用room-item组件时传入了跳转函数,所以在entire页面中点击item图片可以跳转; 而home页面使用room-item时并没有传入任何函数,所以不会执行任何跳转操作,等于什么都没有发生
- ==2.传递数据(store方法)==
- 创建store-detail-toolkit方法,用来保存当前点击的item的单项数据itemData,具体redux代码省略
- ==注意:== 因为刷新页面会清空redux内容,所以为了更好的调试页面,可以抽取一个itemData作为detail-store的默认初始化数据initalState
- 最后保存数据进入store
  ```jsx
    /** 事件处理 */
    const navigate = useNavigate()
    const dispatch = useDispatch()
    const itemClickHandle = useCallback((itemData) => {
      navigate('/detail') // 跳转detail页面
      dispatch(changeDetailInfoAction(itemData)) // 保存数据
    },[])
  ```
### 图片展示与遮盖层
- 详情页detail布局,布局了图片部分和信息部分,信息没有数据,可以自己模拟,所以没写
- 图片的样式等复制了老师代码,==要注意的是一个css样式的蒙版思路,可以看`/detail/c=cpns/detail-pictures`的代码==
### 图片浏览器
- 1.点击图片进入图片浏览器,很通用的组件`/base-ui/picture-browser`
- 1.1在`views/detail/c-cpns/detail-pictures`, 就是我们之前做的图片展示页,做一个简单的显示/隐藏图片浏览器的功能
  ```jsx
    {showBrowser && <PictureBrowser pictureUrls={detailInfo.picture_urls} closeClick={e => setShowBrowser(false)}/>}
  ```
  > 同时传入图片轮播的数组和给自定义事件传入函数,这个closeClick绑定的就是图片浏览器右上角的`X`
- 1.2 小细节,打开浏览器轮播没有滚动条,所以在图片浏览器组件中加入这个代码
  ```jsx
    // 当图片浏览器展示时,关闭浏览器的滚动功能,即删除滚动条
    useEffect(() => {
      document.body.style.overflow = 'hidden' // 删除滚动
      return () => {
        document.body.style.overflow = 'auto' // 有滚动条,离开图片浏览器后,需要恢复滚动条,detail页面是有滚动条的
      }
    }, [])
  ```
- ==2.布局图片浏览器(上中下) 样式直接复制的==
- 2.1上层的代码很简单, 就是控制图片浏览器的开关
   ```js
    // 接受父组件关闭图片浏览器的处理函数
    function closeBtnClickHandle() {
      if (closeClick) closeClick()
    }
  ```
  ```jsx
    <div className='top'>
      <div className='close-btn' onClick={closeBtnClickHandle}>
        <IconClose />
      </div>
    </div>
  ```
- 2.2中层的图片显示不是轮播,而是特殊的动画,新的图片从右侧进入,旧的图片就不设置动画了
- 图片切换是根据url切换的,不是传统地把图片都先渲染出来,然后在'可视窗口'轮播展示,不可以借助传统的动画css,需要借助库`react-transition-group`,实现动画效果
- ==**在react19上面需要处理findNodeDOM问题,需要额外传入nodeRef**==
  ```js
    const { pictureUrls, closeClick } = props // 接受图片数组和关闭图片浏览器的函数(父传子,子触发)
    const [currentIndex, setCurrentIndex] = useState(0) // 现在点击的图片索引
    const [isNext,setIsNext] = useState(true) // 是否是下一个(即点击右箭头)
    const imgRef = useRef(null) // 提前准备ref获取dom对象

    function controlBtnClickHandle(isNext = true) {
      let newIndex = isNext ? currentIndex + 1 : currentIndex - 1 // 判断上一个/下一个
      const length = pictureUrls.length - 1
      if (newIndex < 0) newIndex = length
      if (newIndex > length) newIndex = 0
      setCurrentIndex(newIndex)    
      setIsNext(isNext)
    }
  ```
  ```jsx
    <div className='slider'>
        <div className='control'>
          <div className='btn left' onClick={e => controlBtnClickHandle(false)}> <IconArrowLeft width={77} height={77} /> </div>
          {/* 当前显示的图片 */}
          <div className='picture'>
            {/* 动画切换: 先进后出 */}
            <SwitchTransition mode='in-out'>
              {/* 需要处理findNodeDOM的问题,通过nodeRef属性传入元素的dom对象(issue-918) */}
              <CSSTransition nodeRef={imgRef} key={pictureUrls[currentIndex]} classNames='pic' timeout={200}>
                <img src={pictureUrls[currentIndex]} alt="" ref={imgRef}/>
              </CSSTransition>
            </SwitchTransition>
          </div>
          <div className='btn right' onClick={e => controlBtnClickHandle()}> <IconArrowRight width={77} height={77} /> </div>
        </div>
    </div>
  ```
  > 复用svg(左右箭头),同时传入宽高,之前对这两个svg动态设置过宽高
  ```css
    /* 动画css */
    /* 初始状态 */
    .pic-enter{
      /* 依据左右箭头定义动画 */
      transform: translateX(${props => props.$isNext ? '100%' : '-100%'});
      opacity: 0;
    }
    /* 进入时的动画 */
    .pic-enter-active{
      transform: translateX(0);
      opacity: 1;
      transition: all 200ms ease; 
    }
  ```
  > 图片从左侧进还是从右侧进取决于传入的isNext参数,这是js传入css,特殊地,记得加`$`,这是非html传统属性
- ==3.底层轮播其的显示,直接引入封装的`indicator`==
- 3.1之前封装的时候就考虑到,轮播单项不一定是小圆点等,所以这里很自由,只需要传入数组就可以
- 注意处理里面的信息小细节等
  ```js
    function indicatorClickHandle(index){
      setIsNext(index > currentIndex) // 控制图片从哪个(左/右)方向进入
      setCurrentIndex(index)
    }
  ```
  ```jsx
    {/* 指示器的轮播列表,可以是任意的数组 */}
    <div className='list'>
        <Indicator selectIndex={currentIndex}>
          {
            pictureUrls.map((item,index) => {
              return (
                <div 
                  className={classNames('item',{active: currentIndex === index})} 
                  key={item}
                  onClick={e => indicatorClickHandle(index)}  
                >
                  <img src={item} alt="" />
                </div>
              )
            })
          }
        </Indicator>
    </div>
  ```
  > 处理点击indicator实现图片跳转的核心就是改变currentIndex(当前展示图片的索引)
- 3.2轮播指示器其上方的信息
  ```jsx
    {/* 图片轮播指示器indicator */}
    <div className='info'>
      <div className='desc'>
        {/* 图片信息 个数/总个数 */}
        <div className='count'>
          <span>{currentIndex+1}/{pictureUrls.length}</span>
          <span> 图片{currentIndex+1}</span>
        </div>
        <div className='toggle' onClick={e => setShowList(!showList)}>
          <span>{showList ? '隐藏' : '显示' }照片列表</span>
          {showList ? <IconTriangleBottom/> : <IconTriangleTop/>}
        </div>
      </div>
  ```
  > css思路调整指示器的高度,对height添加动画效果,然后上方的信息是相对于指示器绝对定位的,所以当指示器高度逐渐变为0,上方信息紧贴着向下,实现类似动画的效果,但其实它并没有动画css,只有一个绝对定位
### 阻止冒泡
- 一个小细节,在处理好所有页面后,原来的entire左右箭头的事件会冒泡到顶部,触发跳转详情页detail的事件,所以额外给箭头事件处理函数传递额外的参数event(默认参数)
  ```js
    // room-item
    // 1.跳转上一个/下一个面板
    function controlClickHandle(isRight = true,event) {
      // ....
      // 阻止事件冒泡
      event.stopPropagation()
    }
  ```
## Header二次搭建
- 主要针对顶部header-center的动画效果等搭建
- 不同的页面展示的效果是不同的
  - home: 只有动画
  - entire: 固定定位没有动画
  - detail: 没有定位没有动画
### isFixed
- ==1.创建store/main.js用于记录header-center在不同页面的效果==
- main.js: 代表许多页面公用的store信息,比如用户id等
  ```js
    import { createSlice } from "@reduxjs/toolkit";

    export const mainSlice = createSlice({
      name:'main',
      initialState:{
        headerConfig:{
          isFixed: true // 以Fixed属性为例
        }
      },
      reducers:{
        changeHeaderConfigAction(state,{payload}){
          state.headerConfig = payload
        }
      }
    })

    export const { changeHeaderConfigAction } = mainSlice.actions
    export default mainSlice.reducer
  ```
  > ==之后关于顶部的样式会传入store中,对应的页面获取store后把样式应用于不同的网页中==
  > 注意: 关于顶部的思路提供一种简单的做法(当时在搭建顶部时没有采取这个方法): 当时在封装AppHeader组件时,没有选择三个页面分别封装AppHeader组件,而是在App.jsx中统一使用了一个AppHeader,这样三个页面用同一个实例会相互影响,比较复杂; 而分为三个实例在三个页面使用,则不会互相影响;
- ==2.三个页面使用,例如fixed==
  ```js
    // home.jsx
    /** 派发事件: 发送网络请求,不传参数 */
    const dispatch = useDispatch()
    useEffect(() => {
      dispatch(fetchHomeDataAction())
      dispatch(changeHeaderConfigAction({isFixed: true}))
    }, [])
  ```
  > 以home页面为例子,同理entire和detail页面,不过detail页面没有固定,所以填false
  > 这样进入对应的网页,会修改store中对应的css关键配置
- ==2.1 根据store修改css==
  ```js
    // components/app-header
    const AppHeader = memo(() => {
      const {headerConfig} = useSelector((state)=>({
        headerConfig: state.main.headerConfig
      }),shallowEqual)
      const {isFixed} = headerConfig
      console.log(isFixed)

      return (
        <HeaderWrapper className={classNames({fixed: isFixed})}>
          <HeaderLeft/>
          <HeaderCenter/>
          <HeaderRight/>
        </HeaderWrapper>
      )
    })
  ```
  > 三个页面均使用同一个app-header组件,在进入页面的同时会修改store配置,然后app-header获取这个修改过的store配置,之后修改app-header的css样式
  ```jsx
    export const HeaderWrapper = styled.div`
      display: flex;
      align-items: center;
      height: 80px;
      border-bottom: 1px solid #eee;

      &.fixed{
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background-color: #fff;
        z-index: 99;
      }
    `
  ```
- ==2.2小细节==(源码特性): 异步页面的事件无法监听,颠倒suspense和provider嵌套顺序即可(suspense在provider内部),异步加载的页面都属于suspense的一部分
  - webpack有关: suspense加载的异步比如 home/entire/detail这种页面
  - 源码中`subscribe`不监听异步发出的事件
  - ==react19好像修复了,即使没有颠倒顺序,所以没改==
- ==2.3额外的,entire过滤器也是固定定位==`entire/cpns/entire-filter`,额外设置下style即可
  - ==注意: 后面结项时,修改了过滤器的z-index为19,不会被内容遮盖同时不会遮盖header的展开; 另外title(共XX处住处)的margin(top)调整为130px,因为当header与filter都fixed时会造成高度塌陷,所以补全它们两个的高度塌陷,它们的高度是固定的==
  - `Suspense`主要对异步加载组件进行处理,但是如果放在最外层可能会对app-header app-footer组件进行无谓的二次加载,所以可以把Suspense范围缩小到仅对异步组件(懒加载的路由)进行限制
  ```jsx
      <Provider store={store}>
        {/* 公开css主题 theme */}
        <ThemeProvider theme={theme}>
          <HashRouter>
            <App />
          </HashRouter>
        </ThemeProvider>
      </Provider>
  ```
- ==删除Suspense,进入App组件,如下==
  ```jsx
    const App = memo(() => {
      return (
        <div className='app'>
          <AppHeader />
          <Suspense fallback='loading'>
            <div className='page'>
              {useRoutes(routes)}
            </div>
          </Suspense>
          <AppFooter />
        </div>
      )
    })
  ```
### 搭建新header
- ==1.改装app-header,格式如下图== 
  [![pVpzhxH.png](https://s21.ax1x.com/2025/05/30/pVpzhxH.png)](https://imgse.com/i/pVpzhxH)
- 1.content和蒙版cover app-header
  ```html
    <HeaderWrapper className={classNames({fixed: isFixed})}>
      <div className='content'>
        <div className='top'>
          <HeaderLeft/>
          <HeaderCenter/>
          <HeaderRight/>
        </div>
        <div className='search-area'></div>
      </div>
      <div className='cover'></div>
    </HeaderWrapper>
  ```
- ==2.app-header/header-center: 展示情况也不同==
- 复制coderwhy之前封装过的简单的tab组件和模拟数据(assets/data/search_titles)
- SearchSections是通过定位显示在search-area里面的

### 切换header
- ==1.app-header: 通过`isSearch`判断是否是搜索模式,搜索模式下展示新的header样式==
  ```jsx
    /** 定义内部组件状态 */
    const [isSearch,setIsSearch] = useState(false)

    return (
      <HeaderWrapper className={classNames({fixed: isFixed})}>
        <div className='content'>
          <div className='top'>
            <HeaderLeft/>
            <HeaderCenter isSearch={isSearch} searchBarClick={e => setIsSearch(true)}/>
            <HeaderRight/>
          </div>
          {/* 有动画,它不可以和cover一样直接显示/消失 */}
          <SearchAreaWrapper $isSearch={isSearch}/>
        </div>
        {/* 只有搜索模式下才会显示 */}
        { isSearch && <div className='cover' onClick={e => setIsSearch(false)}></div> }
      </HeaderWrapper>
    )
  ```
  ```jsx
    export const SearchAreaWrapper = styled.div`
      transition: height 250ms ease;
      height: ${props => props.$isSearch ? '100px' : '0'};
    `
  ```
  > 对原来的`search-area`的div标签改装为组件,传入`isSearch`变量,在其css中判断高度的动画,蒙版显示同理,不过没有动画,所以简单些
- ==2.控制是否进入搜索模式==
  - 看上面的代码: 点击蒙版退出搜索模式
  - 点击header-center的搜索框进入搜索模式,但是需要往组件内部传入变量控制,如下
  ```jsx
    // header-center
    const { isSearch, searchBarClick } = props
    function searchBarClickHandle() {
      if (searchBarClick) searchBarClick()
    }

    return(
      <div className='search-bar' onClick={searchBarClickHandle}>
        <div className='text'>
          搜索房源和体验
        </div>
        <div className='icon'>
          <IconSearchBar />
        </div>
      </div>
    )
  ```
  > 给搜索框绑定点击事件,通过执行父传子的函数,进入搜索模式
- ==3.header-center, 详细的动画效果可以没有,学会切换也足够,动画的css样式略==
  ```jsx
    const SearchBarEL = (
      <div className='search-bar' onClick={searchBarClickHandle}>
        <div className='text'>
          搜索房源和体验
        </div>
        <div className='icon'>
          <IconSearchBar/>
        </div>
      </div>
    )

    const SearchDetailEl = (
      <div className='search-detail'>
        <SearchTabs titles={titles} tabClick={setTabIndex}/>
        {/* 给infos设置定位,使得组件SearchSections显示在正确的位置,仅在组件内设置css不足以让组件在页面居中 */}
        <div className='infos'>
          <SearchSections searchInfos={SearchTitles[tabIndex].searchInfos}/>
        </div>
      </div>
    )

    return (
      <CenterWrapper>
        { isSearch ? SearchDetailEl : SearchBarEL }    
      </CenterWrapper>
    )
  ```
  > 这是没有动画的代码,直接硬性切换,效果也还行,主要是动画切换的具体执行有些复杂,直接复制老师的css
- ==4.额外的,鼠标滚动一点点距离也会触发动画消失==  
  - 设置新的hooks,监听scrollY scrollX的值,之前封装过,==同时使用`underscore`库来节流'监听滚动'的行为==,不要太频繁
  - ==在使用hooks时,相当于hooks内部的代码嵌入的当前组件,所以hooks内部的设置state时会导致当前组件重新渲染,所以要节流==
  ```js
    import { useEffect, useState } from "react";
    import { throttle } from "underscore";

    export function useScrollPosition(){
      // 记录位置
      const [scrollX,setScrollX] = useState(0)
      const [scrollY,setScrollY] = useState(0)

      useEffect(() => {
        // 节流
        const handleScroll = throttle(function(){
          setScrollX(window.scrollX)
          setScrollY(window.scrollY)
        },100)

        window.addEventListener('scroll', handleScroll)
        return () => {
          window.addEventListener('scroll',handleScroll)
        }
      })

      return {scrollX,scrollY}
    }
  ```
- 记录Y的滚动,==记住要记录搜索框出来后,滚动的距离差==
  ```js
    /** hooks监听窗口滚动 */
    const {scrollY} = useScrollPosition()
    const preY = useRef(0)
    // 在正常滚动情况下,一直记录scrollY
    if(!isSearch) preY.current = scrollY
    // 在弹出搜索框的情况下,滚动距离大于之前记录距离30px,退出搜索模式收回搜索框
    if(isSearch && Math.abs(scrollY - preY.current) > 30) setIsSearch(false) 
  ```
### topAlpha
- 顶部透明效果,只有home(主页)顶部会有topAlpha的效果
- ==**涉及多个组件使用isAlpha,所以使用ThemeProvider共享`isAlpha`的值,从而动态更新style显示**==
- 然后在header的各种组件中修改`isAlpha`情况下的样式 header-left/center/right等
  ```jsx
     <ThemeProvider theme={{isAlpha}}>
      <HeaderWrapper className={classNames({ fixed: isFixed })}>
        <div className='content'>
          <div className='top'>
            <HeaderLeft />
            <HeaderCenter isSearch={ isAlpha || isSearch} searchBarClick={e => setIsSearch(true)} />
            <HeaderRight />
          </div>
          {/* 有动画,它不可以和cover一样直接显示/消失 */}
          <SearchAreaWrapper $isSearch={isSearch} />
        </div>
        {isSearch && <div className='cover' onClick={e => setIsSearch(false)}></div>}
      </HeaderWrapper>
    </ThemeProvider>
  ```
  > 涉及许多css的修改就省略了,都是`${props => props.theme.isAlpha ? A : B}`
- ==小细节: 在滚动到顶部时,一定是搜索状态,简单的写法就如上面的代码`HeaderCenter + isSearch={ isAlpha || isSearch}`,'或'的特点,前面为true后面就不用判断了,如果前面为false,后面看实际情况,所以这个代码的逻辑就是只要isAlpha为ture,传给isSearch的参数就是true,即开启搜索模式==





